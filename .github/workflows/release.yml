name: Release

on:
  push:
    tags:
      - 'v*.*.*'

# Explicitly define permissions needed for releases
permissions:
  contents: write  # Required to create releases and upload assets

env:
  BUILD_TYPE: Release

jobs:
  get-version:
    name: Get Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      tag: ${{ steps.get_version.outputs.tag }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get version from tag
      id: get_version
      run: |
        TAG_NAME=${GITHUB_REF#refs/tags/}
        VERSION=${TAG_NAME#v}

        # Validate version format (semantic versioning)
        if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
          echo "Error: Invalid version format: $VERSION"
          echo "Expected format: v1.2.3 or v1.2.3-beta.1"
          exit 1
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "Building release for version: $VERSION"

    - name: Generate changelog
      id: changelog
      run: |
        # Get previous tag
        PREV_TAG=$(git describe --abbrev=0 --tags $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")

        if [ -z "$PREV_TAG" ]; then
          echo "No previous tag found, generating changelog from all commits"
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges | head -n 50)
        else
          echo "Generating changelog from $PREV_TAG to HEAD"
          CHANGELOG=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
        fi

        # Handle empty changelog
        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="- No changes documented"
        fi

        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

  build-linux:
    name: Build Linux Release
    needs: get-version
    # C++20 support: ubuntu-latest (GCC 11+)
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          libglfw3-dev \
          libgl1-mesa-dev \
          libglu1-mesa-dev \
          libcurl4-openssl-dev \
          xorg-dev \
          file \
          wget

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          external/imgui
          external/json
        key: release-deps-imgui-1.92.4-json-3.11.3
        restore-keys: |
          release-deps-

    - name: Setup ImGui
      run: |
        if [ ! -d "external/imgui" ]; then
          mkdir -p external
          cd external
          git clone --branch v1.92.4 --depth 1 https://github.com/ocornut/imgui.git
        fi

    - name: Setup nlohmann/json
      run: |
        if [ ! -d "external/json" ]; then
          mkdir -p external
          cd external
          git clone --branch v3.11.3 --depth 1 https://github.com/nlohmann/json.git
        fi

    - name: Build
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }}
        cmake --build build --config ${{ env.BUILD_TYPE }} --parallel

    - name: Package tarball
      run: |
        mkdir -p MetaImGUI-${{ needs.get-version.outputs.version }}-linux
        cp build/MetaImGUI MetaImGUI-${{ needs.get-version.outputs.version }}-linux/
        cp README.md MetaImGUI-${{ needs.get-version.outputs.version }}-linux/
        cp -r resources MetaImGUI-${{ needs.get-version.outputs.version }}-linux/
        tar -czf MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz MetaImGUI-${{ needs.get-version.outputs.version }}-linux

    - name: Build AppImage
      run: |
        # Download linuxdeploy
        wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
        chmod +x linuxdeploy-x86_64.AppImage

        # Create AppDir structure
        mkdir -p AppDir/usr/bin
        mkdir -p AppDir/usr/share/applications
        mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
        mkdir -p AppDir/usr/share/metainfo
        mkdir -p AppDir/usr/share/MetaImGUI

        # Copy executable
        cp build/MetaImGUI AppDir/usr/bin/

        # CRITICAL: Copy resources (including translations.json)
        if [ -d "resources" ]; then
          cp -r resources AppDir/usr/share/MetaImGUI/
          echo "✓ Resources copied to AppDir (including translations)"
        else
          echo "⚠️  WARNING: resources directory not found!"
          exit 1
        fi

        # Create custom AppRun script (sets METAIMGUI_APPDIR for resource path detection)
        cat > AppDir/AppRun << 'APPRUNEOF'
        #!/bin/bash
        # Custom AppRun for MetaImGUI
        # This sets up the environment so the app can find its resources

        # Get the directory where the AppImage is mounted
        APPDIR="$(dirname "$(readlink -f "$0")")"

        # Set up resource paths
        export METAIMGUI_APPDIR="$APPDIR"

        # Change to a writable directory (user's home) for config files
        cd "$HOME"

        # Run the application
        exec "$APPDIR/usr/bin/MetaImGUI" "$@"
        APPRUNEOF

        chmod +x AppDir/AppRun
        echo "✓ Custom AppRun script created"

        # Create desktop entry
        cat > AppDir/usr/share/applications/metaimgui.desktop << 'EOF'
        [Desktop Entry]
        Type=Application
        Name=MetaImGUI
        Comment=ImGui Application Template
        Exec=MetaImGUI
        Icon=metaimgui
        Categories=Development;
        Terminal=false
        EOF

        # Copy icon if it exists, otherwise create placeholder
        if [ -f "resources/icons/metaimgui-256.png" ]; then
          cp resources/icons/metaimgui-256.png AppDir/usr/share/icons/hicolor/256x256/apps/metaimgui.png
          echo "✓ Application icon copied"
        else
          echo "⚠️  Icon not found, creating placeholder"
          touch AppDir/usr/share/icons/hicolor/256x256/apps/metaimgui.png
        fi

        # Build AppImage (skip AppStream validation)
        export NO_APPSTREAM=1
        ./linuxdeploy-x86_64.AppImage --appdir AppDir --output appimage

        # Rename to include version
        mv MetaImGUI-*.AppImage MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage || true

        # Verify resources are in the AppImage
        if [ -f "MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage" ]; then
          echo "✓ AppImage created successfully"
          ./MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage --appimage-extract > /dev/null
          if [ -f "squashfs-root/usr/share/MetaImGUI/resources/translations/translations.json" ]; then
            echo "✓ VERIFIED: translations.json is present in AppImage"
          else
            echo "❌ ERROR: translations.json NOT found in AppImage!"
            echo "Expected: squashfs-root/usr/share/MetaImGUI/resources/translations/translations.json"
            echo "Contents of usr/share/MetaImGUI:"
            ls -la squashfs-root/usr/share/MetaImGUI/
            exit 1
          fi
          rm -rf squashfs-root
        fi

    - name: Generate checksums
      run: |
        sha256sum MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz > MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz.sha256
        if [ -f "MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage" ]; then
          sha256sum MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage > MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage.sha256
        fi

    - name: Upload Release Assets
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.get-version.outputs.tag }}
        draft: false
        files: |
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz.sha256
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage.sha256
        body: |
          ## Changes in this release

          ${{ needs.get-version.outputs.changelog }}

          ## Downloads

          ### Linux
          - **Tarball**: `MetaImGUI-*-linux-x64.tar.gz` - Extract and run
          - **AppImage**: `MetaImGUI-*-linux-x64.AppImage` - Portable, no installation needed

          ### Windows
          - **Installer**: `MetaImGUI-*-Setup.exe` - Installs to Program Files, creates shortcuts
          - **Portable**: `MetaImGUI-*-windows-x64-portable.zip` - Extract and run, no installation

          ### macOS
          - **DMG**: `MetaImGUI-*-macos-x64.dmg` - Drag to Applications folder

          ## Installation

          See the [README](https://github.com/andynicholson/MetaImGUI#readme) for detailed installation instructions.

          ## Checksums

          SHA256 checksums are provided for all artifacts (`.sha256` files).
        fail_on_unmatched_files: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-windows:
    name: Build Windows Release
    needs: get-version
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1

    - name: Cache vcpkg packages
      uses: actions/cache@v4
      with:
        path: C:/vcpkg/installed
        key: ${{ runner.os }}-vcpkg-glfw3-curl
        restore-keys: |
          ${{ runner.os }}-vcpkg-

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          external/imgui
          external/json
        key: release-deps-imgui-1.92.4-json-3.11.3
        restore-keys: |
          release-deps-

    - name: Install NSIS
      run: |
        choco install nsis -y
      shell: pwsh

    - name: Install dependencies (vcpkg)
      run: |
        vcpkg install glfw3:x64-windows curl:x64-windows
      shell: bash

    - name: Setup ImGui
      run: |
        if [ ! -d "external/imgui" ]; then
          mkdir -p external
          cd external
          git clone --branch v1.92.4 --depth 1 https://github.com/ocornut/imgui.git
        fi
      shell: bash

    - name: Setup nlohmann/json
      run: |
        if [ ! -d "external/json" ]; then
          mkdir -p external
          cd external
          git clone --branch v3.11.3 --depth 1 https://github.com/nlohmann/json.git
        fi
      shell: bash

    - name: Build and create packages
      run: |
        # Use the packaging script (creates both NSIS installer and portable ZIP)
        .\packaging\create_windows_installer.ps1 -Version ${{ needs.get-version.outputs.version }}
      shell: pwsh
      env:
        VCPKG_ROOT: C:/vcpkg

    - name: Generate checksums
      run: |
        # Generate checksum for portable ZIP
        $zipHash = (Get-FileHash -Path "packaging\output\MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64-portable.zip" -Algorithm SHA256).Hash
        "$zipHash  MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64-portable.zip" | Out-File -FilePath "packaging\output\MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64-portable.zip.sha256" -Encoding ASCII

        # Generate checksum for installer
        $exeHash = (Get-FileHash -Path "packaging\output\MetaImGUI-${{ needs.get-version.outputs.version }}-Setup.exe" -Algorithm SHA256).Hash
        "$exeHash  MetaImGUI-${{ needs.get-version.outputs.version }}-Setup.exe" | Out-File -FilePath "packaging\output\MetaImGUI-${{ needs.get-version.outputs.version }}-Setup.exe.sha256" -Encoding ASCII
      shell: pwsh

    - name: Upload Release Assets
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.get-version.outputs.tag }}
        draft: false
        files: |
          packaging/output/MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64-portable.zip
          packaging/output/MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64-portable.zip.sha256
          packaging/output/MetaImGUI-${{ needs.get-version.outputs.version }}-Setup.exe
          packaging/output/MetaImGUI-${{ needs.get-version.outputs.version }}-Setup.exe.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-macos:
    name: Build macOS Release
    needs: get-version
    runs-on: macos-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install dependencies
      run: |
        brew install cmake glfw llvm
        LLVM_PATH=$(brew --prefix llvm)
        SDK_PATH=$(xcrun --show-sdk-path)
        echo "$LLVM_PATH/bin" >> $GITHUB_PATH
        echo "CC=$LLVM_PATH/bin/clang" >> $GITHUB_ENV
        echo "CXX=$LLVM_PATH/bin/clang++" >> $GITHUB_ENV
        echo "SDKROOT=$SDK_PATH" >> $GITHUB_ENV
        echo "CPPFLAGS=-isysroot $SDK_PATH" >> $GITHUB_ENV
        echo "LDFLAGS=-L$LLVM_PATH/lib/c++ -Wl,-rpath,$LLVM_PATH/lib/c++" >> $GITHUB_ENV

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          external/imgui
          external/json
        key: release-deps-imgui-1.92.4-json-3.11.3
        restore-keys: |
          release-deps-

    - name: Setup ImGui
      run: |
        if [ ! -d "external/imgui" ]; then
          mkdir -p external
          cd external
          git clone --branch v1.92.4 --depth 1 https://github.com/ocornut/imgui.git
        fi

    - name: Setup nlohmann/json
      run: |
        if [ ! -d "external/json" ]; then
          mkdir -p external
          cd external
          git clone --branch v3.11.3 --depth 1 https://github.com/nlohmann/json.git
        fi

    - name: Build
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0
        cmake --build build --config ${{ env.BUILD_TYPE }} --parallel

    - name: Import Code-Signing Certificates
      uses: Apple-Actions/import-codesign-certs@v5
      with:
        p12-file-base64: ${{ secrets.MACOS_CERTIFICATE }}
        p12-password: ${{ secrets.MACOS_CERTIFICATE_PWD }}
      continue-on-error: true

    - name: Prepare App Bundle
      run: |
        # CMake already created MetaImGUI.app because of MACOSX_BUNDLE
        # Just verify it exists and copy it to the working directory
        if [ ! -d "build/MetaImGUI.app" ]; then
          echo "Error: MetaImGUI.app bundle not found!"
          echo "Looking for bundle in build directory..."
          ls -la build/
          exit 1
        fi

        echo "✓ Found CMake-built bundle at build/MetaImGUI.app"

        # Copy the CMake-built bundle to working directory
        cp -R build/MetaImGUI.app ./

        # Verify the executable is in the bundle
        if [ ! -f "MetaImGUI.app/Contents/MacOS/MetaImGUI" ]; then
          echo "Error: Executable not found in bundle!"
          ls -la MetaImGUI.app/Contents/MacOS/
          exit 1
        fi

        echo "✓ Bundle structure verified"

        # Verify resources are in the bundle
        if [ ! -f "MetaImGUI.app/Contents/Resources/resources/translations/translations.json" ]; then
          echo "⚠️  Warning: translations.json not found in bundle!"
          echo "Bundle contents:"
          find MetaImGUI.app/Contents/Resources -type f
        else
          echo "✓ Resources verified in bundle"
        fi

        # Update Info.plist with version info
        /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ needs.get-version.outputs.version }}" MetaImGUI.app/Contents/Info.plist
        /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString ${{ needs.get-version.outputs.version }}" MetaImGUI.app/Contents/Info.plist

        # Try to add icon if available
        if [ -f "resources/icons/metaimgui.svg" ] && command -v iconutil &> /dev/null; then
          echo "Generating app icon..."
          cd resources/icons
          ./generate_icons.sh || true
          cd ../..
          if [ -f "resources/icons/metaimgui.icns" ]; then
            cp resources/icons/metaimgui.icns MetaImGUI.app/Contents/Resources/
            echo "✓ Icon added to app bundle"
          fi
        fi

    - name: Bundle Dynamic Libraries
      run: |
        echo "Bundling dynamic libraries into app bundle..."

        # Ensure Frameworks directory exists
        mkdir -p MetaImGUI.app/Contents/Frameworks

        # Function to recursively copy and fix library dependencies
        bundle_library() {
          local lib_path="$1"
          local lib_name=$(basename "$lib_path")

          # Skip system libraries
          if [[ "$lib_path" == /System/* ]] || [[ "$lib_path" == /usr/lib/lib* ]]; then
            return
          fi

          # Skip if already bundled
          if [ -f "MetaImGUI.app/Contents/Frameworks/$lib_name" ]; then
            return
          fi

          echo "Bundling: $lib_name"
          cp "$lib_path" MetaImGUI.app/Contents/Frameworks/
          chmod +w "MetaImGUI.app/Contents/Frameworks/$lib_name"

          # Fix the library's install name
          install_name_tool -id "@executable_path/../Frameworks/$lib_name" \
            "MetaImGUI.app/Contents/Frameworks/$lib_name" || true

          # Get and fix dependencies of this library
          otool -L "MetaImGUI.app/Contents/Frameworks/$lib_name" | grep -v ":" | grep -v "@" | awk '{print $1}' | while read -r dep; do
            if [[ ! "$dep" == /System/* ]] && [[ ! "$dep" == /usr/lib/lib* ]]; then
              local dep_name=$(basename "$dep")
              if [ -f "$dep" ]; then
                bundle_library "$dep"
                install_name_tool -change "$dep" "@executable_path/../Frameworks/$dep_name" \
                  "MetaImGUI.app/Contents/Frameworks/$lib_name" || true
              fi
            fi
          done
        }

        # Get all dependencies of the executable
        echo "Analyzing executable dependencies..."
        otool -L MetaImGUI.app/Contents/MacOS/MetaImGUI

        # Bundle each non-system library
        otool -L MetaImGUI.app/Contents/MacOS/MetaImGUI | grep -v ":" | grep -v "@" | awk '{print $1}' | while read -r lib; do
          # Skip system libraries
          if [[ "$lib" == /System/* ]] || [[ "$lib" == /usr/lib/libSystem* ]] || \
             [[ "$lib" == /usr/lib/libc++* ]] || [[ "$lib" == /usr/lib/libobjc* ]] || \
             [[ "$lib" == /usr/lib/libresolv* ]]; then
            continue
          fi

          if [ -f "$lib" ]; then
            lib_name=$(basename "$lib")
            bundle_library "$lib"

            # Update the executable to look in Frameworks directory
            install_name_tool -change "$lib" "@executable_path/../Frameworks/$lib_name" \
              MetaImGUI.app/Contents/MacOS/MetaImGUI || true
          fi
        done

        echo "Bundled libraries:"
        ls -lh MetaImGUI.app/Contents/Frameworks/

        echo "Final executable dependencies:"
        otool -L MetaImGUI.app/Contents/MacOS/MetaImGUI

    - name: Code Sign App Bundle
      run: |
        # Note: entitlements.plist already exists in repo

        # Sign all frameworks first
        if [ -d "MetaImGUI.app/Contents/Frameworks" ]; then
          echo "Signing frameworks..."
          for framework in MetaImGUI.app/Contents/Frameworks/*.dylib; do
            if [ -f "$framework" ]; then
              echo "Signing $(basename "$framework")"
              codesign --force --sign "Developer ID Application" \
                --options runtime \
                --timestamp \
                "$framework" || echo "⚠️  Skipped signing $(basename "$framework")"
            fi
          done
        fi

        # Sign the executable
        codesign --force --sign "Developer ID Application" \
          --options runtime \
          --entitlements entitlements.plist \
          --timestamp \
          MetaImGUI.app/Contents/MacOS/MetaImGUI || echo "⚠️  Code signing skipped (no certificate)"

        # Sign the app bundle (don't use --deep as we've signed components individually)
        codesign --force --sign "Developer ID Application" \
          --options runtime \
          --timestamp \
          MetaImGUI.app || echo "⚠️  Code signing skipped (no certificate)"

        # Verify signature
        codesign --verify --deep --strict --verbose=2 MetaImGUI.app || echo "⚠️  App bundle is unsigned"

        # Show what was signed
        echo "Signature details:"
        codesign -dvvv MetaImGUI.app || true
      continue-on-error: true

    - name: Create DMG
      run: |
        # Create a temporary directory for DMG contents
        mkdir -p dmg_contents
        cp -r MetaImGUI.app dmg_contents/

        # Add Applications folder symlink for better UX
        ln -s /Applications dmg_contents/Applications

        # Create DMG
        hdiutil create -volname "MetaImGUI" -srcfolder dmg_contents -ov -format UDZO MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg

    - name: Generate checksum
      run: |
        shasum -a 256 MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg > MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg.sha256

    - name: Upload Release Assets
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.get-version.outputs.tag }}
        draft: false
        files: |
          MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg
          MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
