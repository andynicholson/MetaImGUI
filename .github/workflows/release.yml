name: Release

on:
  push:
    tags:
      - 'v*.*.*'

# Explicitly define permissions needed for releases
permissions:
  contents: write  # Required to create releases and upload assets

env:
  BUILD_TYPE: Release

jobs:
  get-version:
    name: Get Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      tag: ${{ steps.get_version.outputs.tag }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get version from tag
      id: get_version
      run: |
        TAG_NAME=${GITHUB_REF#refs/tags/}
        VERSION=${TAG_NAME#v}

        # Validate version format (semantic versioning)
        if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
          echo "Error: Invalid version format: $VERSION"
          echo "Expected format: v1.2.3 or v1.2.3-beta.1"
          exit 1
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "Building release for version: $VERSION"

    - name: Generate changelog
      id: changelog
      run: |
        # Get previous tag
        PREV_TAG=$(git describe --abbrev=0 --tags $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")

        if [ -z "$PREV_TAG" ]; then
          echo "No previous tag found, generating changelog from all commits"
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges | head -n 50)
        else
          echo "Generating changelog from $PREV_TAG to HEAD"
          CHANGELOG=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
        fi

        # Handle empty changelog
        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="- No changes documented"
        fi

        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

  build-linux:
    name: Build Linux Release
    needs: get-version
    # C++20 support: ubuntu-latest (GCC 11+)
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          libglfw3-dev \
          libgl1-mesa-dev \
          libglu1-mesa-dev \
          libcurl4-openssl-dev \
          xorg-dev \
          file \
          wget

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          external/imgui
          external/json
        key: release-deps-imgui-1.92.4-json-3.11.3
        restore-keys: |
          release-deps-

    - name: Setup ImGui
      run: |
        if [ ! -d "external/imgui" ]; then
          mkdir -p external
          cd external
          git clone --branch v1.92.4 --depth 1 https://github.com/ocornut/imgui.git
        fi

    - name: Setup nlohmann/json
      run: |
        if [ ! -d "external/json" ]; then
          mkdir -p external
          cd external
          git clone --branch v3.11.3 --depth 1 https://github.com/nlohmann/json.git
        fi

    - name: Build
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }}
        cmake --build build --config ${{ env.BUILD_TYPE }} --parallel

    - name: Package tarball
      run: |
        mkdir -p MetaImGUI-${{ needs.get-version.outputs.version }}-linux
        cp build/MetaImGUI MetaImGUI-${{ needs.get-version.outputs.version }}-linux/
        cp README.md MetaImGUI-${{ needs.get-version.outputs.version }}-linux/
        cp -r resources MetaImGUI-${{ needs.get-version.outputs.version }}-linux/
        tar -czf MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz MetaImGUI-${{ needs.get-version.outputs.version }}-linux

    - name: Build AppImage
      run: |
        # Download linuxdeploy
        wget -q https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
        chmod +x linuxdeploy-x86_64.AppImage

        # Create AppDir structure
        mkdir -p AppDir/usr/bin
        mkdir -p AppDir/usr/share/applications
        mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
        mkdir -p AppDir/usr/share/metainfo

        # Copy executable
        cp build/MetaImGUI AppDir/usr/bin/

        # Create desktop entry
        cat > AppDir/usr/share/applications/metaimgui.desktop << 'EOF'
        [Desktop Entry]
        Type=Application
        Name=MetaImGUI
        Comment=ImGui Application Template
        Exec=MetaImGUI
        Icon=metaimgui
        Categories=Development;
        Terminal=false
        EOF

        # Create a simple icon (you should replace this with a real icon)
        touch AppDir/usr/share/icons/hicolor/256x256/apps/metaimgui.png

        # Build AppImage
        ./linuxdeploy-x86_64.AppImage --appdir AppDir --output appimage

        # Rename to include version
        mv MetaImGUI-*.AppImage MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage || true

    - name: Generate checksums
      run: |
        sha256sum MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz > MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz.sha256
        if [ -f "MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage" ]; then
          sha256sum MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage > MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage.sha256
        fi

    - name: Upload Release Assets
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.get-version.outputs.tag }}
        draft: false
        files: |
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.tar.gz.sha256
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage
          MetaImGUI-${{ needs.get-version.outputs.version }}-linux-x64.AppImage.sha256
        body: |
          ## Changes in this release

          ${{ needs.get-version.outputs.changelog }}

          ## Downloads

          - **Linux**: Download the `.tar.gz` or `.AppImage` file
          - **Windows**: Download the `.zip` file
          - **macOS**: Download the `.dmg` file

          ## Installation

          See the README for installation instructions.

          ## Checksums

          SHA256 checksums are provided for all artifacts (`.sha256` files).
        fail_on_unmatched_files: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-windows:
    name: Build Windows Release
    needs: get-version
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1

    - name: Cache vcpkg packages
      uses: actions/cache@v4
      with:
        path: C:/vcpkg/installed
        key: ${{ runner.os }}-vcpkg-glfw3-curl
        restore-keys: |
          ${{ runner.os }}-vcpkg-

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          external/imgui
          external/json
        key: release-deps-imgui-1.92.4-json-3.11.3
        restore-keys: |
          release-deps-

    - name: Install dependencies (vcpkg)
      run: |
        vcpkg install glfw3:x64-windows curl:x64-windows
      shell: bash

    - name: Setup ImGui
      run: |
        if [ ! -d "external/imgui" ]; then
          mkdir -p external
          cd external
          git clone --branch v1.92.4 --depth 1 https://github.com/ocornut/imgui.git
        fi
      shell: bash

    - name: Setup nlohmann/json
      run: |
        if [ ! -d "external/json" ]; then
          mkdir -p external
          cd external
          git clone --branch v3.11.3 --depth 1 https://github.com/nlohmann/json.git
        fi
      shell: bash

    - name: Build
      run: |
        cmake -B build `
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} `
          -DCMAKE_TOOLCHAIN_FILE="C:/vcpkg/scripts/buildsystems/vcpkg.cmake"
        cmake --build build --config ${{ env.BUILD_TYPE }} --parallel
      shell: pwsh

    - name: Package portable ZIP
      run: |
        mkdir MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64

        # Copy executable
        if (Test-Path "build/Release/MetaImGUI.exe") {
          cp build/Release/MetaImGUI.exe MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64/
        } elseif (Test-Path "build/MetaImGUI.exe") {
          cp build/MetaImGUI.exe MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64/
        } else {
          Write-Error "MetaImGUI.exe not found!"
          exit 1
        }

        # Copy resources
        if (Test-Path "README.md") {
          cp README.md MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64/
        }
        if (Test-Path "resources") {
          cp -r resources MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64/
        }

        # Copy GLFW DLL from vcpkg
        $glfwDll = "C:/vcpkg/installed/x64-windows/bin/glfw3.dll"
        if (Test-Path $glfwDll) {
          cp $glfwDll MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64/
        }

        # Copy libcurl DLL from vcpkg
        $curlDll = "C:/vcpkg/installed/x64-windows/bin/libcurl.dll"
        if (Test-Path $curlDll) {
          cp $curlDll MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64/
        }

        # Create ZIP
        Compress-Archive -Path MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64 -DestinationPath MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64.zip
      shell: pwsh

    - name: Generate checksum
      run: |
        $hash = (Get-FileHash -Path "MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64.zip" -Algorithm SHA256).Hash
        "$hash  MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64.zip" | Out-File -FilePath "MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64.zip.sha256" -Encoding ASCII
      shell: pwsh

    - name: Upload Release Assets
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.get-version.outputs.tag }}
        draft: false
        files: |
          MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64.zip
          MetaImGUI-${{ needs.get-version.outputs.version }}-windows-x64.zip.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-macos:
    name: Build macOS Release
    needs: get-version
    runs-on: macos-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install dependencies
      run: |
        brew install cmake glfw llvm
        LLVM_PATH=$(brew --prefix llvm)
        SDK_PATH=$(xcrun --show-sdk-path)
        echo "$LLVM_PATH/bin" >> $GITHUB_PATH
        echo "CC=$LLVM_PATH/bin/clang" >> $GITHUB_ENV
        echo "CXX=$LLVM_PATH/bin/clang++" >> $GITHUB_ENV
        echo "SDKROOT=$SDK_PATH" >> $GITHUB_ENV
        echo "CPPFLAGS=-isysroot $SDK_PATH" >> $GITHUB_ENV
        echo "LDFLAGS=-L$LLVM_PATH/lib/c++ -Wl,-rpath,$LLVM_PATH/lib/c++" >> $GITHUB_ENV

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          external/imgui
          external/json
        key: release-deps-imgui-1.92.4-json-3.11.3
        restore-keys: |
          release-deps-

    - name: Setup ImGui
      run: |
        if [ ! -d "external/imgui" ]; then
          mkdir -p external
          cd external
          git clone --branch v1.92.4 --depth 1 https://github.com/ocornut/imgui.git
        fi

    - name: Setup nlohmann/json
      run: |
        if [ ! -d "external/json" ]; then
          mkdir -p external
          cd external
          git clone --branch v3.11.3 --depth 1 https://github.com/nlohmann/json.git
        fi

    - name: Build
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }}
        cmake --build build --config ${{ env.BUILD_TYPE }} --parallel

    - name: Import Code-Signing Certificates
      uses: Apple-Actions/import-codesign-certs@v5
      with:
        p12-file-base64: ${{ secrets.MACOS_CERTIFICATE }}
        p12-password: ${{ secrets.MACOS_CERTIFICATE_PWD }}
      continue-on-error: true

    - name: Create App Bundle
      run: |
        mkdir -p MetaImGUI.app/Contents/MacOS
        mkdir -p MetaImGUI.app/Contents/Resources

        # Verify executable exists
        if [ ! -f "build/MetaImGUI" ]; then
          echo "Error: MetaImGUI executable not found!"
          exit 1
        fi

        cp build/MetaImGUI MetaImGUI.app/Contents/MacOS/

        # Copy resources if they exist
        if [ -d "resources" ]; then
          cp -r resources MetaImGUI.app/Contents/Resources/
        fi

        # Create Info.plist
        cat > MetaImGUI.app/Contents/Info.plist << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>MetaImGUI</string>
            <key>CFBundleIdentifier</key>
            <string>com.metaimgui.app</string>
            <key>CFBundleName</key>
            <string>MetaImGUI</string>
            <key>CFBundleVersion</key>
            <string>${{ needs.get-version.outputs.version }}</string>
            <key>CFBundleShortVersionString</key>
            <string>${{ needs.get-version.outputs.version }}</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
        </dict>
        </plist>
        EOF

    - name: Code Sign App Bundle
      run: |
        # Create minimal entitlements file if needed
        if [ ! -f "entitlements.plist" ]; then
          cat > entitlements.plist << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.cs.allow-jit</key>
            <true/>
            <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
            <true/>
        </dict>
        </plist>
        EOF
        fi

        # Sign the executable
        codesign --force --deep --sign "Developer ID Application" \
          --options runtime \
          --entitlements entitlements.plist \
          --timestamp \
          MetaImGUI.app/Contents/MacOS/MetaImGUI || echo "Code signing skipped (no certificate)"

        # Sign the app bundle
        codesign --force --deep --sign "Developer ID Application" \
          --options runtime \
          --timestamp \
          MetaImGUI.app || echo "Code signing skipped (no certificate)"

        # Verify signature
        codesign --verify --deep --strict --verbose=2 MetaImGUI.app || true
      continue-on-error: true

    - name: Create DMG
      run: |
        # Create a temporary directory for DMG contents
        mkdir -p dmg_contents
        cp -r MetaImGUI.app dmg_contents/

        # Create DMG
        hdiutil create -volname "MetaImGUI" -srcfolder dmg_contents -ov -format UDZO MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg

    - name: Generate checksum
      run: |
        shasum -a 256 MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg > MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg.sha256

    - name: Upload Release Assets
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.get-version.outputs.tag }}
        draft: false
        files: |
          MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg
          MetaImGUI-${{ needs.get-version.outputs.version }}-macos-x64.dmg.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
